<?xml version="1.0" encoding="UTF-8"?><html xmlns:concordion="http://www.concordion.org/2007/concordion"><head><style>* {
  font-family: Arial;
}
body {
  padding: 32px;  
}
pre {
  padding: 6px 28px 6px 28px;
  background-color: #E8EEF7;
}
pre, pre *, code, code *, kbd {
  font-family: Courier New, Courier;
  font-size: 10pt;
}
h1, h1 * {
  font-size: 24pt;	
}
p, td, th, li, .breadcrumbs {
  font-size: 10pt;
}
p, li {
  line-height: 140%;
  max-width: 720px;
}
table {
  border-collapse: collapse;
  empty-cells: show;
  margin: 8px 0px 8px 0px;
}
th, td {
  border: 1px solid black;
  padding: 3px;
}
td {
  background-color: white;
  vertical-align: top;
}
th {
  background-color: #C3D9FF;
}
li {
  margin-top: 6px;
  margin-bottom: 6px; 
}

.example {
  padding: 6px 16px 6px 16px;
  border: 1px solid #C3D9FF;
  margin: 6px 0px 28px 0px;
  background-color: #F5F9FD;
}
.example h3 {
  margin-top: 8px;
  margin-bottom: 8px;
  font-size: 12pt;
}

p.success {
  padding: 2px;
}
.success, .success * {
  background-color: #afa !important;
}
.success pre {
  background-color: #bbffbb;
}
.failure, .failure * {
  background-color: #ffb0b0;
  padding: 1px;
}
.failure .expected {
  text-decoration: line-through;
  color: #bb5050;
}
.ignored, .ignored * {
  background-color: #f0f0f0 !important;	
}

ins {
  text-decoration: none;	
}

.exceptionMessage {
  background-color: #fdd;
  font-family: Courier New, Courier, Monospace;
  font-size: 10pt;
  display: block;
  font-weight: normal;
  padding: 4px;
  text-decoration: none !important;
}
.stackTrace, .stackTrace * {
  font-weight: normal;
}
.stackTrace {
  display: none;
  padding: 1px 4px 4px 4px;
  background-color: #fdd;
  border-top: 1px dotted black;
}
.stackTraceExceptionMessage {
  display: block;
  font-family: Courier New, Courier, Monospace;
  font-size: 8pt;
  white-space: wrap;
  padding: 1px 0px 1px 0px;
}
.stackTraceEntry {
  white-space: nowrap;
  font-family: Courier New, Courier, Monospace;
  display: block;
  font-size: 8pt;
  padding: 1px 0px 1px 32px;
}
.stackTraceButton {
  font-size: 8pt;
  margin: 2px 8px 2px 0px;
  font-weight: normal;
  font-family: Arial;
}

.special {
  font-style: italic;
}
.missing, .missing * {
  background-color: #ff9999;
  color:#bb5050;
  text-decoration: line-through;
}
.surplus, .surplus * {
  background-color: #ff9999;
}
.footer {
  text-align: right;
  margin-top: 40px;
  font-size: 8pt;
  width: 100%;
  color: #999;
}
.footer .testTime {
  padding: 2px 10px 0px 0px;
}

.idea {
  font-size: 9pt;
  color: #888;
  font-style: italic;	
}
.tight li {
  margin-top: 1px;
  margin-bottom: 1px; 
}
.commentary {
  float: right;
  width: 200px;
  background-color: #ffffd0;
  padding:8px;
  border: 3px solid #eeeeb0;	 
  margin: 10px 0px 10px 10px;	 
}
.commentary, .commentary * {
  font-size: 8pt;
}
</style><meta http-equiv="content-type" content="text/html; charset=UTF-8" />             
</head><body><span class="breadcrumbs"><a href="../HmtUtils.html">HMT utilities, version 0.3.0</a> &gt; <a href="Tokenization.html">Tokenization of Greek texts</a> &gt;</span>                                                                          
    <h1>Components shared by all tokenization systems</h1>
<h2>Input and output</h2>
<p>The tokenization process applies to passages of texts identified by a CTS URN.  The tokenizers support two forms of input:</p>
<ol>
<li>a <em>string of text</em>  to parse, accompanied by the passage's URN, and optionally by a CITE URN identifying the kind of context</li>
<li>a <em>delimited text file</em> representing the full OHCO2 model of a text as defined in the <code>hocuspocus</code> library (<a href="http://cite-architecture.github.io/hocuspocus/">http://cite-architecture.github.io/hocuspocus/</a>)</li>
</ol>
<p>In both cases, the output is an ordered list of token analyses. Each token analysis has two parts, a CTS URN for the substring, and a CITE URN analyzing the type of the token.</p>
<h2>Parsing strings of texts</h2>
<p>At a minimum, a request to tokenize a string of text must identify the CTS URN as well as the text content to analyze.  In addition, it is possible to identify the type of context being analyzed with a CITE URN taken from one of the values   <code>urn:cite:hmt:tokentypes.lexical</code>, <code>urn:cite:hmt:tokentypes.numeric</code>, <code>urn:cite:hmt:tokentypes.waw</code>, <code>urn:cite:hmt:tokentypes.sic</code>, or by a CITE URN in either of the two collections <code>urn:cite:hmt:place</code> or <code>urn:hmt:pers</code>.    If the context is <em>not</em> identified with one of these URNs, the content of XML text nodes is treated by default as a <code>GreekString</code> object, which the <code>greeklang</code> library can split into lexical tokens.</p>
<p><div class='example'></p>
<h3>Examples</h3>
<p>If we parse the string of characters, <em concordion:set="#str4">προΐαλλε θοὰς ἐπι νῆας</em>
from the text passage <strong concordion:set="#urn">urn:cts:greekLit:tlg0012.tlg001.msA:11.3</strong>,
we get an ordered list of <strong concordion:assertEquals="countTokens(#str4,#urn)" class="success">4</strong> tokens.</p>
<table concordion:verifyRows="#token : getTokens(#str4,#urn)">
<tr><th concordion:assertEquals="#token">Token string</th></tr>
<tr><td class="success">urn:cts:greekLit:tlg0012.tlg001.msA:11.3@προΐαλλε</td></tr>
<tr><td class="success">urn:cts:greekLit:tlg0012.tlg001.msA:11.3@θοὰς</td></tr>
<tr><td class="success">urn:cts:greekLit:tlg0012.tlg001.msA:11.3@ἐπι</td></tr>
<tr><td class="success">urn:cts:greekLit:tlg0012.tlg001.msA:11.3@νῆας</td></tr>

</table>
<p>Their types are all the same:</p>
<table concordion:verifyRows="#token : getTypes(#str4,#urn)">
<tr><th concordion:assertEquals="#token">Type</th></tr>
<tr><td class="success">urn:cite:hmt:tokentypes.lexical</td></tr>
<tr><td class="success">urn:cite:hmt:tokentypes.lexical</td></tr>
<tr><td class="success">urn:cite:hmt:tokentypes.lexical</td></tr>
<tr><td class="success">urn:cite:hmt:tokentypes.lexical</td></tr>

</table>
<p>If we parse the string <em concordion:set="#zeus">Ζεὺς</em> using the same CTS URN, and specify the context with the CITE URN <strong concordion:set="#pers8">urn:cite:hmt:pers.pers8</strong>, this is analyzed as:</p>
<ul>
<li>token <strong concordion:assertEquals="getToken(#zeus,#urn,#pers8)" class="success">urn:cts:greekLit:tlg0012.tlg001.msA:11.3@Ζεὺς</strong></li>
<li>type  <strong concordion:assertEquals="getType(#zeus,#urn,#pers8)" class="success">urn:cite:hmt:pers.pers8</strong></li>
</ul>
<p></div></p>
<p>By default, requests to tokenize a string do not include explicit index values on the CTS URN substrings, since the most common use may not necessarily be to analyze an entire citable node of text, but explicit subreference indexing can optionally be included.</p>
<p><div class='example'></p>
<p>tis t'ar sfwe qewn eridi cunehke maxesqai;</p>
<p></div></p>
<h2>Parsing delimited text files</h2>
<p>The tabular representation of the HMT project editions preserves the full XML markup of the archival TEI documents, so the HMT tokenizers  can identify the appropriate context from the HMT project's markup conventions.   They can therefore formulate requests with both the CTS URN for the text passage, and a CITE URN classifying the context.  Analyses of delimited text files always include explicit indexes on CTS URN subreferences.</p>
<p><div class='example'></p>
<h3>Examples</h3>
<p>Tokenizing <a href="../../../specs/data/ethnic.txt" concordion:set="#ethnics = setHref(#HREF)">this data file</a> parses Its XML text node into a list of <strong concordion:assertEquals="countTokensInTab(#ethnics)" class="success">8</strong> tokens.</p>
<table concordion:verifyRows="#token : getTokensInTab(#ethnics)">
<tr><th concordion:assertEquals="#token">Token string</th></tr>
<tr><td class="success">urn:cts:greekLit:tlg0012.tlg001.msA:11.3@Ζεὺς[1]</td></tr>
<tr><td class="success">urn:cts:greekLit:tlg0012.tlg001.msA:11.3@δ'[1]</td></tr>
<tr><td class="success">urn:cts:greekLit:tlg0012.tlg001.msA:11.3@Ἔριδα[1]</td></tr>
<tr><td class="success">urn:cts:greekLit:tlg0012.tlg001.msA:11.3@προΐαλλε[1]</td></tr>
<tr><td class="success">urn:cts:greekLit:tlg0012.tlg001.msA:11.3@θοὰς[1]</td></tr>
<tr><td class="success">urn:cts:greekLit:tlg0012.tlg001.msA:11.3@ἐπι[1]</td></tr>
<tr><td class="success">urn:cts:greekLit:tlg0012.tlg001.msA:11.3@νῆας[1]</td></tr>
<tr><td class="success">urn:cts:greekLit:tlg0012.tlg001.msA:11.3@Ἀχαιῶν[1]</td></tr>
</table>
<p>Their types are:</p>
<table concordion:verifyRows="#token : getTypesInTab(#ethnics)">
<tr><th concordion:assertEquals="#token">Types</th></tr>
<tr><td class="success">urn:cite:hmt:pers.pers8</td></tr>
<tr><td class="success">urn:cite:hmt:tokentypes.lexical</td></tr>
<tr><td class="success">urn:cite:hmt:pers.pers156</td></tr>
<tr><td class="success">urn:cite:hmt:tokentypes.lexical</td></tr>
<tr><td class="success">urn:cite:hmt:tokentypes.lexical</td></tr>
<tr><td class="success">urn:cite:hmt:tokentypes.lexical</td></tr>
<tr><td class="success">urn:cite:hmt:tokentypes.lexical</td></tr>
<tr><td class="success">urn:cite:hmt:peoples.place96</td></tr>
</table>
<p></div></p>
<h2>Universally allowed elements and their mapping to token types</h2>
<p>Elements to test:</p>
<ul>
<li><code>w</code></li>
</ul>
<p>Illustrated above:</p>
<ul>
<li><code>persName</code></li>
<li><code>placeName</code></li>
<li><code>rs</code> (@type = 'ethnic')</li>
</ul>
<h2>Elements allowed in "secondary" texts, but not in <em>Iliad</em> editions</h2>
<ul>
<li><code>num</code>: treated as <code>MilesianString</code>s in the <code>greeklang</code> library</li>
<li><code>ref</code> (@type = "urn" and @n=urn value)</li>
<li><code>q</code></li>
<li><code>cit</code></li>
<li><code>rs</code> (type = <code>waw</code>)</li>
<li><code>figDesc</code></li>
<li><code>note</code></li>
</ul>
<h2>Splitting strings</h2>
<p>Both the editorial and diplomatic tokenization systems include utility methods to split strings of text on white space.</p>
<p><div class='example'></p>
<h3>Examples</h3>
<p>The string</p>
<pre concordion:set="#raw">Ζεὺς  δ' Ἔριδα  προΐαλλε θοὰς ἐπι νῆας Ἀχαιῶν</pre>
<p>yields the following ordered set of tokens:</p>
 <table concordion:verifyRows="#token : splitString(#raw)">
<tr><th concordion:assertEquals="#token">Token string</th></tr>

<tr><td class="success">Ζεὺς</td></tr>
<tr><td class="success">δ'</td></tr>
<tr><td class="success">Ἔριδα</td></tr>
<tr><td class="success">προΐαλλε</td></tr>
<tr><td class="success">θοὰς</td></tr>
<tr><td class="success">ἐπι</td></tr>
<tr><td class="success">νῆας</td></tr>
<tr><td class="success">Ἀχαιῶν</td></tr>
</table>
<p></div></p>
<div class="footer">Results generated by <a href="http://www.concordion.org" style="font-weight: bold; text-decoration: none; color: #89C;">Concordion</a><div class="testTime">in 238 ms on 16-Apr-2015 at 23:18:13 EDT</div></div></body>
</html>